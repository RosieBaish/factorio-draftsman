# 2.0 release

manner of validation

```python
blueprint = Blueprint()

blueprint.load_from_string("...")
try:
    blueprint.raise_for_status()
except DraftsmanError:
    raise
```

## Problems:
* Can only resolve one error

```python
blueprint = Blueprint()

blueprint.load_from_string("...") # Can still raise MalformedBlueprintStringError + IncorrectBlueprintTypeError
valid, issues = blueprint.is_valid()
if not valid:
    for issue in issues:
        print(issue.name) # OverlappingObjectsWarning, InvalidEntityError, etc.
        # Handle the issue somehow
```

## True Errors
```
DraftsmanError
IncorrectBlueprintTypeError
DuplicateIDError
InvalidAssociationError
IncompatibleModError
MissingModError
IncorrectModVersionError
IncorrectModFormatError
MalformedBlueprintStringError
```

## Validation Errors
```
InvalidEntityError(?)
InvalidOperationError
InvalidModeError
InvalidWireTypeError
InvalidConnectionSideError
InvalidRecipeError
InvalidModuleError
InvalidInstrumentID
InvalidNoteID
InvalidSideError
InvalidFluidError
EntityNotPowerConnectableError
EntityNotCircuitConnectableError
InvalidTileError
InvalidSignalError
InvalidItemError
```

```python
# Example entity
accumulator = Accumulator()

# Optional validation for entity attributes can be done with an external toggle:
draftsman.entity_validation = True # Toggle
accumulator.control_behavior = {"incorrect": "format"} # DataFormatError

draftsman.entity_validation = False
accumulator.control_behavior = {"incorrect": "format"} # No issue

# For a generic query on whether or not to consider this entity valid, more a quick
# idiot check, we can do:
if not accumulator.is_valid():
    print("This entity is not valid")

# Most likely though, the user will want some control over what parts to consider valid, 
# so something like this makes sense:
if not accumulator.is_valid(DataFormatError, InvalidWireConnectionError)
    # This will ignore all other issues aside from the two issues above
    print("The accumulator has a DataFormatError or an InvalidWireConnectionError!")

# For a more fine grained inquiry, we can search and collect "issues" (Errors + Warnings)
issues = accumulator.collect_issues()
# Similar to above, the user will most likely want some interface to specifically 
# select particular issues over others
# For example, we can separate the issues list into errors and warnings
for error in issues.errors:
    # handle errors

for warning in issues.warnings:
    # handle warnings
```

```python
issues = entity.validate()
for issue in issues:
    pass
```


Signal stuff
------------

We need to be able to specify `entity.signal = {"name": ..., "type": ...}` because since we're getting rid of permanent validation Draftsman might not be able to deduce the type of the signal from its name:

```python
# Assuming a vanilla draftsman install
accumulator = Accumulator()

accumulator.output_signal = "filter-combinator" # This either errors here, as we try to convert to dict
accumulator.validate() # Or here, if we modify the signal name from a string to a dict here
accumulator.to_dict() # Or here, if we try to create a usable dict and we cannot determine the signal type

# instead, we must do
accumulator.output_signal = {"name": "filter-combinator", "type": "item"}
# Or a possible shorthand
accumulator.output_signal = ("filter-combinator", "item")
```

Or, we could add a data function that allows the user to add the signal to the raw data and then everything can stay the same:

```python

from draftsman.data import signals

signals.add_signal("filter-combinator", "item") # Add the signal to signals.raw for the lifetime of this program
# add_signal would also have an optional sort string so it can be placed in correct order to preserve ordering, by default it gets appended

accumulator = Accumulator()
accumulator.output_signal = "filter-combinator" # This causes no errors

```

errors can be issued on regular functions if and only if meaning cannot be deduced from the input arguments
adding something that's not an entity to an entity list, because we only know how to convert entitylikes to json when exporting
TypeErrors on arguments that are integers when they need to be ranges, or strings when they need to be dicts
warnings can also be issued on regular functions, if there is some clear mistake but not critical to operation at this moment
setting an inventory bar to be greater than the inventory size is the classical example; wrong from a strict standpoint, but functionally harmless to importing/exporting
making a blueprint too large would be a warning, because draftsman has no trouble doing this; only trouble arises when exporting
inspect() can be called at any time, which performs complex validation checks, such as checking a blueprint/entity's entire structure
inspect() returns a series of errors and warnings that can be interpreted by the end user or ignored
Exactly what format is up to debate. In two lists, errors and warnings, or all together? Sorted by severity, so when iterating you get the worst ones first?
Finally, during Factorio resolution (to_dict() and to_string()), we call inspect with the same user type idiom of

for issue in blueprint.inspect():
    raise issue

which means any chronic issue that prevents import into Factorio would be raised at this step
NO: the user should be able to break things if they so desire

Format validation vs content validation: they are different! Maybe:

```python

accumulator = Accumulator()
accumulator.output_signal = "signal-A" # Pre-2.0 would be converted to a dict
assert accumulator.output_signal == "signal-A" # though not anymore

# In order to have this change take place, we call validate(), which is distinct from inspect():
accumulator.validate()
assert accumulator.output_signal == {"name": "signal-A", "type": "virtual"}

# if validate went well, we can maybe use this to improve performance. Suppose we create a blueprint and 1000 of the above accumulators to it:

blueprint = Blueprint()
for i in range(1000):
    blueprint.entities.append(accumulator, tile_position=(i*accumulator.tile_width, 0))

# Then, if we were to validate the blueprint, we don't really need to check if the entities are valid because each one is a copy of a blueprint that we know is valid
# So we only have to validate 1 entity instead of 1000
blueprint.validate() # Ideally this would have basically no performance impact

# The question then becomes, should inspect() return format errors/warnings?
```

I'm thinking no. Inspect ideally should handle issues with the contents of blueprints, complex things that are much more involved then a simple formatting check.

Furthermore, we can think about this in terms of output strings as well. `validate()` must be called at some point before `to_dict()` or `to_string()`, because it needs to be resolved to the correct format by nature of the function. However, `inspect()` does *not* need to be called beforehand, or at all; it may resolve in an issue on import, but not one that relates to the format of the passed in object.\

So, validation should not happen on attribute set/get. This behaves more like one would expect, so that any value that is set is immediately retrievable as the same value:

```python
accumulator.output_signal = "signal-A"
assert accumulator.output_signal == "signal-A"
```

If you call `validate()`, this resolves the signal to the correct format expected by Factorio:

```python
accumulator.validate()
assert accumulator.output_signal == {"name": "signal-A", "type": "virtual"}
```

Draftsman is able to infer the extra metadata because `"signal-A"` is recognized in `data`. However, this may not always be the case:

```python
accumulator.output_signal = "some-modded-signal"
assert accumulator.output_signal == "some-modded-signal"

accumulator.validate() # Throws exception!
```

Draftsman throws and *exception* because it cannot possibly know what the `"type"` of that modded signal is; and therefore cannot ensure that the result of converting it to a dict will return a properly formatted blueprint string.

There are a number of ways around this. If signal is *explicitly* defined, either by the user or an imported blueprint, then the validation has everything it needs to know to produce the blueprint string:

```python
accumulator.output_signal = {"name": "some-modded-signal", "type": "virtual"}
assert accumulator.output_signal == {"name": "some-modded-signal", "type": "virtual"}

accumulator.validate() # Fine
```

You can also add the signal to `data` manually and draftsman will recognize it for that python session:

```python
from draftsman.data import signals

signals.add_signal("some-modded-signal", "virtual")

accumulator.output_signal = "some-modded-signal"
assert accumulator.output_signal == "some-modded-signal"

accumulator.validate() # Fine
```

The old method of installing the mod with `"some-modded-signal"` still works as well, of course.

`validate()` is automatically called by `to_dict()` and `to_string()`, so the end user doesn't have to call it. The benefit to splitting it into it's own function is that the user has control of exactly when it takes place. If a user sets a signal many hundreds or thousands of times, the validation only needs to be performed once; if the user wants to set the variable to a different, breaking value, they can (until they want to export it); and theoretically it should allow certain subcomponents to be checked if they're valid and not traverse them if they are.
Should validate use that cache thing that casa-sui mentioned?

`inspect()` is more complex. Instead of asking, "is this value okay?", it asks, "does this value make sense?":

```python
accumulator.output_signal = "some-modded-signal"
assert accumulator.output_signal == "some-modded-signal"

error_list, warning_list = accumulator.inspect() # Does this have to validate accumulator in order to work?
print(warning_list)
# [UnrecognizedElementWarning("Unrecognized signal 'some-modded-signal'")]
```

`inspect()` should create a *human readable* digest, or it should be very easy to coerce to produce a human readable digest. 
`inspect()` is for additional issues that come from a object that otherwise passes it's schema validation.

Errors returned by inspect are guaranteed to fail importing into Factorio, including things like entries being the wrong datatype (or should that be handled by validate?), or the blueprint being too large across one or more of it's axes.
Warnings returned by inspect are everything else; they *can* cause errors (things like unrecognized entities; they might exist in the Factorio context and be fine, but they also might not and raise an error), as well as just regular old useless/redundant keys or values.

validate is for schema correctness, inspect is for any additional restrictions
by that axiom, then things like datatype correctness must be ensured by validate

So validate can operate as a cached property, something like `is_valid`
When checking the validity of some entity, it first checks to see if `is_valid` is `True`, and early exits if so; Otherwise, it goes through the whole validation shebang

This is how we get the 1 -> 1000 performance gain mentioned above; we go through each entity and call `entity.validate()`, and they all are `is_valid` so it skips every one
We then simply set it up so that if any attribute of the entity is modified, it invalidates `is_valid`, so validate must be performed once again at some point before `to_dict()`

What about when creating entities? Does creating a new entity from scratch guarantee that `is_valid` starts as `True`? 
A: No, validate will always have to be called at some point afterwards to ensure that the arguments passed to it were correct. It has a certain level of confidence over it's own structure though; maybe if no arguments are passed then it can consider itself valid? (strange circumstance though, and almost never used. Unlikely to be desirable)


# 2.0 Release

The development of Draftsman might have seemed to slow over the past few months, but this is not quite true. Instead, I've been spending the last half a year or so working on the next revision of the module which attempts to address the most fundamental problems with it. This has been no trivial matter, and what started as a simple set of minor updates ballooned into a massive major update which spans all of the current remaining issues with Draftsman, and hopefully leaves it in a better place going forward. This document gives an overview of what exactly I perceive these issues to be, as well as their new solutions in Draftsman 2.0.

## Deferred Validation

### The Problem

A big problem with Draftsman 1.0 is that it doesn't provide any real provisions for users working with blueprint configurations that Draftsman has no knowledge of. For example, consider the following case where we try to import a modded entity under a vanilla Factorio configuration:

```py
my_modded_blueprint = {
    "blueprint": {
        "item": "blueprint",
        "entities": [
            {
                "name": "my-modded-entity",
                "position": {"x": 0.5, "y": 0.5}
            }
        ]
    }
}

blueprint = Blueprint(my_modded_blueprint) # InvalidEntityError: 'my-modded-entity'
```

Draftsman complains because it doesn't recognize the entity, and thus cannot meaningfully check it's correctness. From Draftsman's perspective, this makes sense; what's the dimension of this entity? What does it collide with? Is it circuit connectable? What attributes does it have? What are their allowed values? Because Draftsman cannot validate this object to the caliber of any known entity, it decides to consider it a catastrophic error and defer to the user to either remove it or update Draftsman's environment.

This is great for a number of circumstances, such as the case where you thought you were operating in a modded context but actually weren't, or in the case where the entity's name was simply a misspelled version of a known entity, which you likely want to catch as early as possible.

The problem is that there are other situations where this is too restrictive. A user might very well want to just *ignore* any unknown entities/tiles and simply return a Blueprint with the known ones, which is in fact how Factorio itself behaves. Going further, you might want to actually preserve these modded entities in the created blueprint; you might want to swap the modded entity to a known one which Draftsman can more easily handle, or maybe you don't want to touch the modded stuff at all and simply pass it to the game, asserting that the game will know how to handle it even if Draftsman doesn't.

Because the members of `draftsman.data` are fully writable, you can add new entries in their corresponding dictionaries or lists to "trick" Draftsman into allowing these cases. Unfortunately, there are no helper methods which actually make this a palatable option. Care must be taken to provide all of the necessary information in the exact correct format  Draftsman expects, which is also likely to be inconsistent across Draftsman versions to boot. The only real sanctioned in Draftsman 1.0 for interacting with modded entities is to modify the entire data configuration by running `draftsman-update` (or the corresponding method in `env.py`). This is easy if you're creating the blueprint string yourself with a set of mods that you're actively playing with, but difficult if:

* You change your mod configuration to something different but still want to load the modded string anyway,
* You receive the blueprint string from an external source which is running a different mod configuration (of which you may have no knowledge what mods were used!)
* You want to keep the script simple, and have it work with any environment configuration so that anyone can simply just run the script, dammit.

Clearly, this is a design flaw due to a simplification set early on when designing the tool. Since Draftsman runs the data lifecycle to extract validation information and can do so dynamically, I assumed that all of the needed data would be available at the script runtime, when this is not truly the case. As a result, Draftsman 1.0 is essentially a "greedy" validator, requiring comprehensive information about the entire environment before running, which is useful in some settings, but not in others.

Another related flaw about Draftsman 1.0 is that even if you want Draftsman to panic, you cannot tell it *when* to do so. Suppose for example that we want to swap all instances of a particular modded entity from a blueprint, but we still want to error if we detect any *other* modded entities. We would like to then write something similar to this:

```py
modded_string = "..."
blueprint = Blueprint(modded_string, validate=False)

for i, entity in blueprint.entities:
    if entity.name == "modded-lamp":
        blueprint.entities[i] = Lamp("small-lamp", position=entity.position)

blueprint.validate() # InvalidEntityError: 'my-modded-entity'
```

... but this is also impossible in Draftsman 1.0. Validation of the `Blueprint` always happens at construction, and cannot be deferred until later; the only other option is to modify the data going into `Blueprint` before constructing it, but this would be more verbose since we're working with dict keys, and we wouldn't have access to all of the nice helper methods that `Blueprint` already provides.

Finally, a user may also desire more control of the manner and types of warnings/errors which are issued. Some users might want to check just the format of the input data so that no fields have the incorrect type; others might want a comprehensive analysis of all of the field values, to check for redundancies or conceptual faults. You might want to treat errors as warnings, or warnings as errors, or ignore validation completely. What validation should do is more than a simple "yes" or "no", and so a big goal for 2.0 was to allow users to configure it specifically to their desires.

### The Solution

As a result, in **Draftsman 2.0** all Draftsman objects now have a `validate()` function which can be used to check their contents at any point after they're created. The function takes a `ValidationMode` parameter, which is an enum which indicates the strictness of the validation, which controls the type and quantity of errors and warnings:

* `NONE`: No validation whatsoever. Every attribute remains exactly as it was; even values in a known shorthand format are not converted. Impossible to know whether or not this object will import into Factorio when using this mode. This tells Draftsman to simply treat every object verbatim.
* `MINIMUM`: Only returns formatting errors, where data members are of incorrect types. For example, if you set the name of an entity to an integer, this would raise a `DataFormatError`. Besides this, no other warnings or errors are issued. This tells Draftsman to error if the object is in a form that it absolutely knows will NOT import into Factorio.
* `STRICT`: This is the default mode, most closely related to the behavior of Draftsman 1.0. It returns all above errors, as well as most of the errors and warnings most users of the module will be familiar with, in addition to a few new ones. For example, if Draftsman now encounters an entity it doesn't recognize, it issues a `UnknownEntityWarning` instead of an `InvalidEntityError`; Draftsman doesn't know about this entity, but it *may* import into Factorio if the game knows about it.
* `PEDANTIC`: Issues all above errors and warnings, as well as providing more linting-like behavior as well. A good example is setting the limiting bar of a container beyond it's total inventory slots; this creates no issue when importing into the game, and the container behaves as if the bar was set at that point; but it might indicate a conceptual failure from the programmers perspective, and as such it will raise a `BarWarning` if detected under this validation mode.

Instead of raising the errors and warnings in place, `validate()` returns a wrapper object called a `ValidationResult`. This object contains an `error_list` and a `warning_list` attribute, which can be read, modified, iterated over, saved for later, or any combination thereof. The following snippet simply reissues any detected errors or warnings found with a blueprint:

```py
blueprint = Blueprint()

# Modify the blueprint in some way...

result = blueprint.validate(mode=ValidationMode.STRICT)
for error in result.error_list:
    raise error
for warning in result.warning_list:
    warnings.warn(warning)
```

Because the above pneumonic is likely to appear a lot, it's implemented as a helper method called `reissue_all()`:

```py
blueprint = Blueprint()

blueprint.validate(mode=ValidationMode.STRICT).reissue_all() # Identical to the above code
```

Creating a `ValidationResult` object also makes it very easy to add other helper methods like `reissue_all()` as well as additional functionality later on without breaking code in written in earlier versions of 2.0.

Similar to their prior behavior, all `Blueprintable` and `Entity` subclasses still support validation during construction, with the benefit of being able to configure exactly how using the new keyword argument `validate`:

```py
messed_up_data = {
    "name": "unknown", # Should raise a warning
    "tags": "incorect" # Should raise an error
}

container = Container(**messed_up_data, validate=ValidationMode.NONE) # No issues!
assert container.name == "unknown"
assert container.tags == "incorrect"
assert container.to_dict() == { # Even serialization still works
    "name": "unknown",
    "tags": "incorect"
}

# Now validate it
result = container.validate()
assert len(result.error_list) == 1
```

In addition to the `validate` parameter, both `Blueprintable` and `Entity` subclasses also have a `validate_assignment` parameter, which configures whether or not to run validation when assigning an attribute of the object:

```py
container = Container(validate_assignment=ValidationMode.STRICT)

container.name = TypeError          # Raises an error because of type mismatch
container.name = "unknown"          # Raises a warning because it's not recognized
container.name = "electric-furnace" # Raises a warning because it's not a Container

# `validate_assignment` can be set at any point in the objects lifetime
container.validate_assignment = ValidationMode.NONE

container.name = TypeError          # Nothing
container.name = "unknown"          # Nothing
container.name = "electric-furnace" # Nothing

# `validate_assignment` is a per-instance attribute, so individual entities can have their own validation severity
container2 = Container(validate_assignment=ValidationMode.STRICT)

assert container.validate_assignment is not container2.validate_assignment
```

In an effort to provide more flexibility while still keeping the API consistent across many different functions and attributes, Draftsman now has 3 "categories" of manipulating objects for all the validatable types:

1. Dict-like modification, such as `entity["member"] = ...`; This mode is guaranteed to not run validation ever, regardless of the value of `validate_assignment`. As a consequence, this method is also guaranteed to be computationally cheap.
2. Attribute access, such as `entity.member = ...`; The behavior of this mode is configurable, depending on the value of `validate_assignment`. Usually the most terse syntax.
3. Helper function, such as `entity.set_member(...)`; This mode is guaranteed to run validation always, regardless of the value of `validate_assignment`. Also potentially provides additional functionality, such as setting defaults or formatting complex structures such as conditions, connections, etc.

In Draftsman 1.0, helper methods were used primarily for either setting attributes via shorthand, or for setting complex structures more easily. They retain these functions in 2.0, but now shorthands of all types can be used with the attribute syntax as well. Note however that shorthand resolution is tied to validation, so if validation is disabled in an entity's `validate_assignment`, it won't be able to handle shorthand formats automatically.

Finally, in addition to `validate` and `validate_assignment`, `EntityCollection` and `TileCollection` subclasses now also have an `if_unknown` string parameter which indicates what should happen if an unknown entity or tile is appended to a blueprint. To illustrate this more clearly, let's take a look at `draftsman.entity.new_entity()` which also supports this keyword:

```py
from draftsman.error import InvalidEntityError, DataFormatError
from draftsman.entity import Entity, new_entity

# Regular, known entities work as you would expect without issue
container = new_entity("wooden-chest")
assert container.type == "container"

# By default, `if_unknown` is "error", which raises an exception
# (a la Draftsman's current behavior)
try:
    error_result = new_entity("unknown", if_unknown="error")
except InvalidEntityError:
    pass

# Setting to "ignore" simply returns nothing if unrecognized 
omitted_result = new_entity("unknown", if_unknown="ignore")
assert omitted_result is None

# "accept" is the final option, and is the most interesting
result = new_entity("unknown", position=(0.5, 0.5), if_unknown="accept")

# Result in this case is actually an instance of the base `Entity` parent class
assert isinstance(result, Entity)

# As a result, all of the parameters known to Entity are available
result.position += (10, 10)
result.tags = {"extra": "Tons of extra information we can use."}

# In addition, we can even add new parameters to this entity and Draftsman won't complain,
# which is different from a known container
result["extra_parameter"] = "amazing!"

# We can then serialize this object with the new keys intact
assert result.to_dict() == {
    "name": "unknown",
    "position": {"x": 10.5, "y": 10.5},
    "tags": {"extra": "Tons of extra information we can use."},
    "extra_parameter": "amazing!"
}

# And we can even still get validation for the few attributes we do know about!
try:
    result.tags = "incorrect" # DataFormatError: tags must be a dict
except DataFormatError:
    pass
```

And finally, for those who just want to update Draftsman's data on the fly, there are now helper methods for all the class types in `draftsman.data` which allow you to add new or modify existing data:

```py
from draftsman.data import entities
from draftsman.entity import Container

entities.add_entity(
    name="new-container",
    entity_type="container",
    collision_box=((-0.4, -0.4), (0.4, 0.4)),
    inventory_size=100
    # Any other relevant keyword arguments can be provided and will be added to
    # the raw data entry
)

# "new-container" is now in all the correct places
assert "new-container" in entities.raw
assert "new-container" in entities.containers
# (NOTE: sort order is not currently preserved when adding at runtime)
# (This is harder than it sounds so I'm posteponing this until later)

container = Container("new-container")
assert (container.tile_width, container.tile_height) == (1, 1)
assert container.position == Vector(0.5, 0.5)
assert container.inventory_size == 100

# "new-container" will persist until the script ends
```

These methods are provided as a way to allow Draftsman to remain maximally strict against unknown data, but permit the user to quickly update said data just for the scope of a single script. This is provided mainly as a stopgap for cases where only a few entities/tiles are needed, which may be faster and/or simpler than grabbing the mod files themselves and running `draftsman-update`.

Hopefully these new features will allow users of 2.0 to have much more control of the manner in which their structures are validated, (hopefully) firmly crossing this one off the TODO list.

## Validation is now done with `pydantic` instead of `schema`

All of this new magic is facilitated with the [Pydantic](TODO) validation library. I went through a number of different libraries before I finally settled on Pydantic; the primary reasons were:

* Pydantic schemas are defined using Python type hints instead of a custom internal language specific to the library, making it easier for other maintainers to contribute to the project and generally make the whole validation code much easier on the eyes.
* Pydantic allows to specify custom validation functions which can be run at basically any point during the validation step, before, after, during, and can even stop validation altogether halfway through. With conditional enabling/disabling of these functions, it should also be possible to make version specific checks to allow for not only consistent validation, but also validation specific to a particular Factorio version. Perhaps even users themselves could add their own custom validation functions. Even if I don't stick with Pydantic ultimately (it has some problems I've yet to resolve), I firmly believe any future solution will need to have something like this in place.
* Warnings and errors are all integrated into one system, instead of having split and competing ones. In addition, *all* validation uses the same backend, which means that not only does `entity.items = {...}` issue the same warnings as `entity.set_items(...)`, but they both use the exact same code which is defined in one place.
* Pydantic supports JSON schema generation, meaning that you can take any Pydantic model and output an accurate JSON dictionary which describes it's exact format. This can then be extracted and used with *any* compliant JSON schema library to validate inputs of any Draftsman model. Furthermore, with a little bit of help it's highly likely that you could make a human readable digest out of this information, and all fields are given descriptions to help aid in this.

Additionally, the backend of Pydantic is written in Rust, which theoretically might lead to a considerable performance improvement, which was another longstanding issue with Draftsman. Some other ground has been made on this front; simply by reducing the memory of many Draftsman constructs alone has greatly improved the performance on very large blueprintable objects. And, since you can defer or omit validation, it's also theoretically possible to create a script in "slow" mode with validation on at every step, and then selectively turn off validation wherever it's known that the data will always be valid, potentially saving a lot of wall time. Of course, rigorous and concrete benchmarks are still yet to be made, so these performance gains are currently speculation; but I do believe making the library more performant going forward is likely to be much easier.

However, because Pydantic uses type hints to express it's schemas, this means that the new minimum Python version required will be Python 3.7. This also allows Draftsman to use a number of modern Python goodies that were previously precluded from it due to it's backwards compatibility restrictions. For those concerned, Draftsman 1.0 will remain available on PYPI and under the `1.0` branch on Github for anyone still on an older version of Python and can't update, but all new features will likely only exist on the main (2.0) branch going forward.

## `RailPlanner`, `Schedule`, `WaitConditions`, and `TrainConfiguration` (finally)

Another longstanding weak point of Draftsman was it's rudimentary API when interacting with rails, trains, and their schedules. In 2.0, this area has seen large improvements.

For placing rails, the long in-development `RailPlanner` class is now feature functional. It allows you to draw rail paths using turtle-like commands, entirely similar to how the game itself does it:

```py
from draftsman.blueprintable import Blueprint
from draftsman.rail import RailPlanner # New access point for rail related classes

# Create a new RailPlanner
# The name here refers to the vanilla rails, but you can change this to work with
# modded rails as well
planner = RailPlanner(name="rail")

# RailPlanners have a head position and direction, and can move forward, left, or right
planner.head_position = (0, 0)
planner.head_direction = Direction.SOUTH
planner.move_forward(5) # Place 5 straight rails southward
planner.turn_right()    # Turn 45 degrees to the right
planner.turn_left(3)    # Turn 135 degrees to the left, so we're now facing East
planner.move_forward(10)

# The head can be moved and oriented at any point
planner.head_position = (10, 10)
planner.head_direction = Direction.EAST
planner.move_forward(5)

# RailPlanners can also place rail signals (on either side of the track)...
planner.add_signal(entity="rail-signal")
planner.add_signal(entity="rail-chain-signal", right=False)
planner.move_forward(5)

# or train stops (on either side of the track)
planner.add_station(entity="train-stop", station="Name of Station")
planner.move_forward(5)

# Both of the above methods also allow you to pass in an existing entity instance
from draftsman.entity import TrainStop
configured_stop = TrainStop()
configured_stop.station = "Configured Station"
configured_stop.read_from_train = True

# Adds a station with the parameters from `configured_stop`
planner.add_station(entity=configured_stop)

# Now we can simply add the planner to a blueprint
blueprint = Blueprint()
blueprint.entities.append(planner)
print(blueprint.to_string())
```

`TrainConfiguration` allows you to specify a sequence of rolling stock in the community-accepted syntax for describing trains:

```py

```

For more information on how to use the features of the new classes, see [these examples](TODO)

## Numerous Additional Quality of Life Features

2.0 also provides a number of straightforward improvements over 1.0:

1. `Direction` and `Orientation` are now more than just normal enumerations, and support all of the methods supported with the Factorio Standard Library:

```py
>>> from draftsman.constants import Direction, Orientation
>>> Direction.NORTH.opposite()
<Direction.SOUTH: 4>
>>> Direction.NORTH.next()
<Direction.EAST: 2>
>>> Direction.NORTH.previous(eight_way=True)
<Direction.NORTHWEST: 7>
>>> Direction.NORTH.to_vector()
<Vector>(0, -1)
>>> Direction.NORTH.to_orientation()
<Orientation.NORTH: 0.0>
>>> Orientation.NORTH.to_direction()
<Direction.NORTH: 0>
>>> Orientation.NORTH.to_vector(magnitude=10)
<Vector>(0, -10)
```

The `Ticks` constant class has also been added, which should make translating time-based periods much easier:

```py
from draftsman.constants import Ticks
from datetime import datetime

assert Ticks.SECOND == 60
assert 5 * Ticks.SECOND == 300

# You can even convert `timedeltas` to ticks
t1 = datetime.strptime("10:15:04", "%H:%M:%S")
t2 = datetime.strptime("10:19:27", "%H:%M:%S")
td = t2 - t1
print(Ticks.from_timedelta(td)) # 15780
```

* `position` and `tile_position` now properly update the other when modifying by attribute `x` or `y`; Example:
* You can now manually specify the `index` of a Blueprintable in a blueprint book manually instead of rearranging the blueprint's list. This allows not only for flexibility, but it also now allows you to specify blueprint books with non-contiguous blueprint entries, which you were previously unable to do in `1.0`.
* A few more example scripts in the `examples` folder, but more excitingly examples are now organized into category directories, and a README.md is provided in each directory which gives an overview of each example.
* `to_dict()` for all functions now have two parameters, `exclude_none` and `exclude_default`. They default to `True`, but can be turned off if you want to ensure that every supplied key makes it out for data consistency reasons. For those worried about blueprint string size, fear not; `to_string()` still uses the minimum format possible, and may even be smaller now than in 1.0.
* Documentation has all been updated to support 2.0, and a new branch on ReadTheDocs has been made to differentiate between 1.0 and 2.0



## Upgrades to data

## Reduced memory footprint

* Almost all information known to the class is now at the class level
    - Before, things like the `rotatable` entity flag were kept as members in each entity instance, even though it's the same for all instances of a particular entity. This is now fixed.
* Lots of parameters are now calculated as needed instead of stored
    - This has the benefit of reducing memory footprint further as well as only performing the calculation when the user actually needs it
    - If the user doesn't want to recalculate it every time, they can choose to cache it at their own discretion

## Future work

* `is_valid` attribute for validation caching
    - This would be very nice, but it is also very complex with the current structure of the project

the list of things TODO has now moved to a dedicated document, with more information about each component. If you're interested in contributing, it should now be easier to see my intentions for the project going forward.